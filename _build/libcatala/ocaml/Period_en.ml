(** This file has been generated by the Catala compiler, do not edit! *)

[@@@ocaml.warning "-4-26-27-32-33-34-37-41-42-69"]

open Catala_runtime


let () =
  match Catala_runtime.check_module "Period_internal" "*external*" with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Period_internal, it may need recompiling"
module Period_internal = Period_internal
let () =
  match Catala_runtime.check_module "Date_en" "CM0|15e33851|32e49b03|1be0e012"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Date_en, it may need recompiling"
module Date_en = Date_en

module Period = struct
  type t = {begin__1: date; end__1: date}
end


(* Toplevel def of_month_and_year *)
let of_month_and_year : Date_en.Month.t -> integer -> Period.t =
  fun (pmonth: Date_en.Month.t) (pyear: integer) ->
    (let pbegin : date =
       ((Date_en.of_year_month_day)
          ({filename="libcatala/period_en.catala_en";
            start_line=25; start_column=7; end_line=25; end_column=29;
            law_headings=["Definitions and operations"; "Periods of time"]})
          pyear ((Date_en.month_to_integer) pmonth) (integer_of_string "1"))
    in
    ({Period.begin__1 = pbegin;
        Period.end__1 = ((Date_en.last_day_of_month) pbegin)}))

(* Toplevel def of_year *)
let of_year : integer -> Period.t =
  fun (pyear: integer) ->
    {Period.begin__1 =
       ((Date_en.of_year_month_day)
          ({filename="libcatala/period_en.catala_en";
            start_line=38; start_column=17; end_line=38; end_column=39;
            law_headings=["Definitions and operations"; "Periods of time"]})
          pyear (integer_of_string "1") (integer_of_string "1"));
       Period.end__1 =
         ((Date_en.of_year_month_day)
            ({filename="libcatala/period_en.catala_en";
              start_line=39; start_column=15; end_line=39; end_column=37;
              law_headings=["Definitions and operations"; "Periods of time"]})
            pyear (integer_of_string "12") (integer_of_string "31"))}

(* Toplevel def valid *)
let valid : Period.t -> bool =
  fun (p: Period.t) ->
    o_not (o_lt_dat_dat (p.Period.end__1) (p.Period.begin__1))

(* Toplevel def duration *)
let duration : Period.t -> duration =
  fun (p: Period.t) ->
    o_sub_dat_dat
      (o_add_dat_dur AbortOnRound
         {filename="libcatala/period_en.catala_en";
          start_line=56; start_column=11; end_line=56; end_column=12;
          law_headings=["Definitions and operations"; "Periods of time"]}
         (p.Period.end__1) (duration_of_numbers (0) (0) (1)))
      (p.Period.begin__1)

(* Toplevel def are_adjacent *)
let are_adjacent : Period.t -> Period.t -> bool =
  fun (p1: Period.t) (p2: Period.t) ->
    o_eq_dat_dat (p1.Period.end__1)
      (o_sub_dat_dur AbortOnRound
         {filename="libcatala/period_en.catala_en";
          start_line=66; start_column=23; end_line=66; end_column=24;
          law_headings=["Definitions and operations"; "Periods of time"]}
         (p2.Period.begin__1) (duration_of_numbers (0) (0) (1)))

(* Toplevel def join *)
let join : Period.t -> Period.t -> Period.t =
  fun (p1: Period.t) (p2: Period.t) ->
    {Period.begin__1 =
       ((Date_en.min) (p1.Period.begin__1) (p2.Period.begin__1));
       Period.end__1 = ((Date_en.max) (p1.Period.end__1) (p2.Period.end__1))}

(* Toplevel def covers *)
let covers : Period.t -> Period.t -> bool =
  fun (long: Period.t) (short: Period.t) ->
    (o_lte_dat_dat (long.Period.begin__1) (short.Period.begin__1)) &&
      (o_lte_dat_dat (short.Period.end__1) (long.Period.end__1))

(* Toplevel def is_contained *)
let is_contained : Period.t -> date -> bool =
  fun (p: Period.t) (d: date) ->
    (o_lte_dat_dat (p.Period.begin__1) d) &&
      (o_lte_dat_dat d (p.Period.end__1))

(* Toplevel def is_before *)
let is_before : Period.t -> date -> bool =
  fun (p: Period.t) (d: date) -> o_lt_dat_dat d (p.Period.begin__1)

(* Toplevel def is_after *)
let is_after : Period.t -> date -> bool =
  fun (p: Period.t) (d: date) -> o_gt_dat_dat d (p.Period.end__1)

(* Toplevel def to_tuple *)
let to_tuple : Period.t -> (date * date) =
  fun (p: Period.t) -> ((p.Period.begin__1), (p.Period.end__1))

(* Toplevel def of_tuple *)
let of_tuple : date -> date -> Period.t =
  fun (begin__1: date) (end__1: date) ->
    {Period.begin__1 = begin__1; Period.end__1 = end__1}

(* Toplevel def intersection *)
let intersection : Period.t -> Period.t -> (Period.t) Optional.t =
  fun (p1: Period.t) (p2: Period.t) ->
    (let intersection__1 : Period.t =
       ({Period.begin__1 =
           ((Date_en.max) (p1.Period.begin__1) (p2.Period.begin__1));
           Period.end__1 =
             ((Date_en.min) (p1.Period.end__1) (p2.Period.end__1))}) in
    ( if (valid intersection__1) then (Optional.Present intersection__1) else
       (Optional.Absent)))

(* Toplevel def find_period *)
let find_period : (Period.t array) -> date -> (Period.t) Optional.t =
  fun (l: Period.t array) (d: date) ->
    o_fold
      (fun (found: (Period.t) Optional.t) (p: Period.t) ->
         match found
         with
         | Optional.Absent ->
             ( if (is_contained p d) then (Optional.Present p) else
                (Optional.Absent))
         | Optional.Present _ -> found) (Optional.Absent) l

(* Toplevel def to_tuple_list *)
let _ : (Period.t array) -> ((date * date) array) =
  fun (l: Period.t array) -> o_map (fun (p: Period.t) -> to_tuple p) l

(* Toplevel def to_tuple_associated_list *)
let to_tuple_associated_list : ((Period.t * 'tt) array) ->
                                 (((date * date) * 'tt) array) =
  fun (l: (Period.t * 'tt) array) ->
    o_map
      (fun (p: (Period.t * 'tt)) ->
         ((to_tuple (let x, _ = p in x)), (let _, x = p in x))) l

(* Toplevel def of_tuple_list *)
let of_tuple_list : ((date * date) array) -> (Period.t array) =
  fun (l: (date * date) array) ->
    o_map
      (fun (tpl: (date * date)) ->
         of_tuple (let x, _ = tpl in x) (let _, x = tpl in x)) l

(* Toplevel def of_tuple_associated_list *)
let of_tuple_associated_list : (((date * date) * 'tt) array) ->
                                 ((Period.t * 'tt) array) =
  fun (l: ((date * date) * 'tt) array) ->
    o_map
      (fun (tpl: ((date * date) * 'tt)) ->
         ((let args : (date * date) = (let x, _ = tpl in x) in
           (of_tuple (let x, _ = args in x) (let _, x = args in x))), (let _,
           x = tpl in x))) l

(* Toplevel def overlaps *)
let overlaps : Period.t -> Period.t -> bool =
  fun (p1: Period.t) (p2: Period.t) ->
    match (intersection p1 p2)
    with
    | Optional.Absent -> false
    | Optional.Present _ -> true

(* Toplevel def split_by_year *)
let split_by_year : Date_en.Month.t -> Period.t -> (Period.t array) =
  fun (starting_month: Date_en.Month.t) (p: Period.t) ->
    of_tuple_list
      ((Period_internal.split_by_year)
         ((Date_en.month_to_integer) starting_month) (to_tuple p))

(* Toplevel def split_by_month *)
let split_by_month : Period.t -> (Period.t array) =
  fun (p: Period.t) ->
    of_tuple_list ((Period_internal.split_by_month) (to_tuple p))

(* Toplevel def sort_by_date *)
let sort_by_date : ((Period.t * 'tt) array) -> ((Period.t * 'tt) array) =
  fun (l: (Period.t * 'tt) array) ->
    (let tuple_associated_list : ((date * date) * 'tt) array =
       (to_tuple_associated_list l) in
    (let sorted_tuple_associated_list : ((date * date) * 'tt) array =
       ((Period_internal.sort) tuple_associated_list) in
    (of_tuple_associated_list sorted_tuple_associated_list)))

let () =
  Catala_runtime.register_module "Period_en"
    [ "of_month_and_year", Stdlib.Obj.repr of_month_and_year;
      "of_year", Stdlib.Obj.repr of_year;
      "valid", Stdlib.Obj.repr valid;
      "duration", Stdlib.Obj.repr duration;
      "are_adjacent", Stdlib.Obj.repr are_adjacent;
      "join", Stdlib.Obj.repr join;
      "covers", Stdlib.Obj.repr covers;
      "is_contained", Stdlib.Obj.repr is_contained;
      "is_before", Stdlib.Obj.repr is_before;
      "is_after", Stdlib.Obj.repr is_after;
      "intersection", Stdlib.Obj.repr intersection;
      "find_period", Stdlib.Obj.repr find_period;
      "overlaps", Stdlib.Obj.repr overlaps;
      "split_by_year", Stdlib.Obj.repr split_by_year;
      "split_by_month", Stdlib.Obj.repr split_by_month;
      "sort_by_date", Stdlib.Obj.repr sort_by_date ]
    "CM0|15e33851|32e49b03|16c825d2"
