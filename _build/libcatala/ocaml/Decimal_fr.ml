(** This file has been generated by the Catala compiler, do not edit! *)

[@@@ocaml.warning "-4-26-27-32-33-34-37-41-42-69"]

open Catala_runtime


let () =
  match Catala_runtime.check_module "Decimal_internal" "*external*" with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Decimal_internal, it may need recompiling"
module Decimal_internal = Decimal_internal


(* Toplevel def min *)
let min : decimal -> decimal -> decimal =
  fun (d1: decimal) (d2: decimal) ->  if (o_gt_rat_rat d1 d2) then d2 else d1

(* Toplevel def max *)
let max : decimal -> decimal -> decimal =
  fun (d1: decimal) (d2: decimal) ->  if (o_gt_rat_rat d1 d2) then d1 else d2

(* Toplevel def troncature *)
let troncature : decimal -> decimal =
  fun (d: decimal) ->
     if (o_eq_rat_rat d (decimal_of_string "0")) then (decimal_of_string "0")
      else
      ( if (o_gt_rat_rat d (decimal_of_string "0")) then
         (o_round_rat (o_sub_rat_rat d (decimal_of_string "1/2"))) else
         (o_round_rat (o_add_rat_rat d (decimal_of_string "1/2"))))

(* Toplevel def arrondi_à_la_décimale *)
let arrondi_a_la_decimale : decimal -> integer -> decimal =
  fun (d: decimal) (nieme_decimale: integer) ->
    (Decimal_internal.round_to_decimal) d nieme_decimale

(* Toplevel def somme *)
let somme : (decimal array) -> decimal =
  fun (l: decimal array) ->
    o_fold (fun (total: decimal) (x: decimal) -> o_add_rat_rat total x)
      (decimal_of_string "0") l

(* Toplevel def plafond *)
let plafond : decimal -> decimal -> decimal =
  fun (d: decimal) (valeur_max: decimal) -> min d valeur_max

(* Toplevel def plancher *)
let plancher : decimal -> decimal -> decimal =
  fun (d: decimal) (valeur_min: decimal) -> max d valeur_min

(* Toplevel def arrondi_par_défaut *)
let arrondi_par_defaut : decimal -> decimal =
  fun (d: decimal) ->
     if (o_gt_rat_rat d (decimal_of_string "0")) then (troncature d) else
      ( if (o_eq_rat_rat (troncature d) d) then d else
         (troncature (o_sub_rat_rat d (decimal_of_string "1"))))

(* Toplevel def arrondi_par_excès *)
let arrondi_par_exces : decimal -> decimal =
  fun (d: decimal) ->
     if (o_gte_rat_rat d (decimal_of_string "0")) then
      ( if (o_eq_rat_rat (troncature d) d) then d else
         (troncature (o_add_rat_rat d (decimal_of_string "1")))) else
      (o_round_rat (o_add_rat_rat d (decimal_of_string "1/2")))

(* Toplevel def positif *)
let positif : decimal -> decimal =
  fun (d: decimal) -> plancher d (decimal_of_string "0")

let () =
  Catala_runtime.register_module "Decimal_fr"
    [ "min", Stdlib.Obj.repr min;
      "max", Stdlib.Obj.repr max;
      "troncature", Stdlib.Obj.repr troncature;
      "arrondi_\195\160_la_d\195\169cimale",
        Stdlib.Obj.repr arrondi_a_la_decimale;
      "somme", Stdlib.Obj.repr somme;
      "plafond", Stdlib.Obj.repr plafond;
      "plancher", Stdlib.Obj.repr plancher;
      "arrondi_par_d\195\169faut", Stdlib.Obj.repr arrondi_par_defaut;
      "arrondi_par_exc\195\168s", Stdlib.Obj.repr arrondi_par_exces;
      "positif", Stdlib.Obj.repr positif ]
    "CM0|15e33851|32e49b03|3af7d45f"
