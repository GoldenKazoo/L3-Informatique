(** This file has been generated by the Catala compiler, do not edit! *)

[@@@ocaml.warning "-4-26-27-32-33-34-37-41-42-69"]

open Catala_runtime


let () =
  match Catala_runtime.check_module "Period_internal" "*external*" with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Period_internal, it may need recompiling"
module Period_internal = Period_internal
let () =
  match Catala_runtime.check_module "Date_fr" "CM0|15e33851|32e49b03|3096d497"
    with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Date_fr, it may need recompiling"
module Date_fr = Date_fr

module Periode = struct
  type t = {debut: date; fin: date}
end


(* Toplevel def depuis_mois_et_année *)
let depuis_mois_et_annee : Date_fr.Mois.t -> integer -> Periode.t =
  fun (pmois: Date_fr.Mois.t) (pannee: integer) ->
    (let pbegin : date =
       ((Date_fr.depuis_annee_mois_jour)
          ({filename="libcatala/period_fr.catala_fr";
            start_line=25; start_column=7; end_line=25; end_column=34;
            law_headings=["Définitions et opérations"; "Périodes de time"]})
          pannee ((Date_fr.mois_vers_entier) pmois) (integer_of_string "1"))
    in
    ({Periode.debut = pbegin;
        Periode.fin = ((Date_fr.dernier_jour_du_mois) pbegin)}))

(* Toplevel def depuis_année *)
let depuis_annee : integer -> Periode.t =
  fun (pannee: integer) ->
    {Periode.debut =
       ((Date_fr.depuis_annee_mois_jour)
          ({filename="libcatala/period_fr.catala_fr";
            start_line=38; start_column=17; end_line=38; end_column=44;
            law_headings=["Définitions et opérations"; "Périodes de time"]})
          pannee (integer_of_string "1") (integer_of_string "1"));
       Periode.fin =
         ((Date_fr.depuis_annee_mois_jour)
            ({filename="libcatala/period_fr.catala_fr";
              start_line=39; start_column=15; end_line=39; end_column=42;
              law_headings=["Définitions et opérations";
                             "Périodes de time"]}) pannee (integer_of_string
            "12") (integer_of_string "31"))}

(* Toplevel def valide *)
let valide : Periode.t -> bool =
  fun (p: Periode.t) ->
    o_not (o_lt_dat_dat (p.Periode.fin) (p.Periode.debut))

(* Toplevel def durée *)
let duree : Periode.t -> duration =
  fun (p: Periode.t) ->
    o_sub_dat_dat
      (o_add_dat_dur AbortOnRound
         {filename="libcatala/period_fr.catala_fr";
          start_line=56; start_column=12; end_line=56; end_column=13;
          law_headings=["Définitions et opérations"; "Périodes de time"]}
         (p.Periode.fin) (duration_of_numbers (0) (0) (1))) (p.Periode.debut)

(* Toplevel def sont_adjacentes *)
let sont_adjacentes : Periode.t -> Periode.t -> bool =
  fun (p1: Periode.t) (p2: Periode.t) ->
    o_eq_dat_dat (p1.Periode.fin)
      (o_sub_dat_dur AbortOnRound
         {filename="libcatala/period_fr.catala_fr";
          start_line=66; start_column=23; end_line=66; end_column=24;
          law_headings=["Définitions et opérations"; "Périodes de time"]}
         (p2.Periode.debut) (duration_of_numbers (0) (0) (1)))

(* Toplevel def union *)
let union : Periode.t -> Periode.t -> Periode.t =
  fun (p1: Periode.t) (p2: Periode.t) ->
    {Periode.debut = ((Date_fr.min) (p1.Periode.debut) (p2.Periode.debut));
       Periode.fin = ((Date_fr.max) (p1.Periode.fin) (p2.Periode.fin))}

(* Toplevel def englobe *)
let englobe : Periode.t -> Periode.t -> bool =
  fun (longue: Periode.t) (courte: Periode.t) ->
    (o_lte_dat_dat (longue.Periode.debut) (courte.Periode.debut)) &&
      (o_lte_dat_dat (courte.Periode.fin) (longue.Periode.fin))

(* Toplevel def est_contenue *)
let est_contenue : Periode.t -> date -> bool =
  fun (p: Periode.t) (d: date) ->
    (o_lte_dat_dat (p.Periode.debut) d) && (o_lte_dat_dat d (p.Periode.fin))

(* Toplevel def est_avant *)
let est_avant : Periode.t -> date -> bool =
  fun (p: Periode.t) (d: date) -> o_lt_dat_dat d (p.Periode.debut)

(* Toplevel def est_après *)
let est_apres : Periode.t -> date -> bool =
  fun (p: Periode.t) (d: date) -> o_gt_dat_dat d (p.Periode.fin)

(* Toplevel def vers_tuple *)
let vers_tuple : Periode.t -> (date * date) =
  fun (p: Periode.t) -> ((p.Periode.debut), (p.Periode.fin))

(* Toplevel def depuis_tuple *)
let depuis_tuple : date -> date -> Periode.t =
  fun (debut: date) (fin: date) -> {Periode.debut = debut; Periode.fin = fin}

(* Toplevel def intersection *)
let intersection : Periode.t -> Periode.t -> (Periode.t) Optional.t =
  fun (p1: Periode.t) (p2: Periode.t) ->
    (let intersection__1 : Periode.t =
       ({Periode.debut =
           ((Date_fr.max) (p1.Periode.debut) (p2.Periode.debut));
           Periode.fin = ((Date_fr.min) (p1.Periode.fin) (p2.Periode.fin))})
    in
    ( if (valide intersection__1) then (Optional.Present intersection__1)
       else (Optional.Absent)))

(* Toplevel def trouve_période *)
let trouve_periode : (Periode.t array) -> date -> (Periode.t) Optional.t =
  fun (l: Periode.t array) (d: date) ->
    o_fold
      (fun (found: (Periode.t) Optional.t) (p: Periode.t) ->
         match found
         with
         | Optional.Absent ->
             ( if (est_contenue p d) then (Optional.Present p) else
                (Optional.Absent))
         | Optional.Present _ -> found) (Optional.Absent) l

(* Toplevel def vers_tuple_liste *)
let _ : (Periode.t array) -> ((date * date) array) =
  fun (l: Periode.t array) -> o_map (fun (p: Periode.t) -> vers_tuple p) l

(* Toplevel def vers_tuple_liste_associée *)
let vers_tuple_liste_associee : ((Periode.t * 'tt) array) ->
                                  (((date * date) * 'tt) array) =
  fun (l: (Periode.t * 'tt) array) ->
    o_map
      (fun (p: (Periode.t * 'tt)) ->
         ((vers_tuple (let x, _ = p in x)), (let _, x = p in x))) l

(* Toplevel def depuis_tuple_liste *)
let depuis_tuple_liste : ((date * date) array) -> (Periode.t array) =
  fun (l: (date * date) array) ->
    o_map
      (fun (tpl: (date * date)) ->
         depuis_tuple (let x, _ = tpl in x) (let _, x = tpl in x)) l

(* Toplevel def depuis_tuple_liste_associée *)
let depuis_tuple_liste_associee : (((date * date) * 'tt) array) ->
                                    ((Periode.t * 'tt) array) =
  fun (l: ((date * date) * 'tt) array) ->
    o_map
      (fun (tpl: ((date * date) * 'tt)) ->
         ((let args : (date * date) = (let x, _ = tpl in x) in
           (depuis_tuple (let x, _ = args in x) (let _, x = args in x))),
           (let _, x = tpl in x))) l

(* Toplevel def chevauche *)
let chevauche : Periode.t -> Periode.t -> bool =
  fun (p1: Periode.t) (p2: Periode.t) ->
    match (intersection p1 p2)
    with
    | Optional.Absent -> false
    | Optional.Present _ -> true

(* Toplevel def divise_par_année *)
let divise_par_annee : Date_fr.Mois.t -> Periode.t -> (Periode.t array) =
  fun (mois_de_depart: Date_fr.Mois.t) (p: Periode.t) ->
    depuis_tuple_liste
      ((Period_internal.split_by_year)
         ((Date_fr.mois_vers_entier) mois_de_depart) (vers_tuple p))

(* Toplevel def divise_par_mois *)
let divise_par_mois : Periode.t -> (Periode.t array) =
  fun (p: Periode.t) ->
    depuis_tuple_liste ((Period_internal.split_by_month) (vers_tuple p))

(* Toplevel def tri_par_date *)
let tri_par_date : ((Periode.t * 'tt) array) -> ((Periode.t * 'tt) array) =
  fun (l: (Periode.t * 'tt) array) ->
    (let tuple_associated_list : ((date * date) * 'tt) array =
       (vers_tuple_liste_associee l) in
    (let sorted_tuple_associated_list : ((date * date) * 'tt) array =
       ((Period_internal.sort) tuple_associated_list) in
    (depuis_tuple_liste_associee sorted_tuple_associated_list)))

let () =
  Catala_runtime.register_module "Period_fr"
    [ "depuis_mois_et_ann\195\169e", Stdlib.Obj.repr depuis_mois_et_annee;
      "depuis_ann\195\169e", Stdlib.Obj.repr depuis_annee;
      "valide", Stdlib.Obj.repr valide;
      "dur\195\169e", Stdlib.Obj.repr duree;
      "sont_adjacentes", Stdlib.Obj.repr sont_adjacentes;
      "union", Stdlib.Obj.repr union;
      "englobe", Stdlib.Obj.repr englobe;
      "est_contenue", Stdlib.Obj.repr est_contenue;
      "est_avant", Stdlib.Obj.repr est_avant;
      "est_apr\195\168s", Stdlib.Obj.repr est_apres;
      "intersection", Stdlib.Obj.repr intersection;
      "trouve_p\195\169riode", Stdlib.Obj.repr trouve_periode;
      "chevauche", Stdlib.Obj.repr chevauche;
      "divise_par_ann\195\169e", Stdlib.Obj.repr divise_par_annee;
      "divise_par_mois", Stdlib.Obj.repr divise_par_mois;
      "tri_par_date", Stdlib.Obj.repr tri_par_date ]
    "CM0|15e33851|32e49b03|17de7a19"
