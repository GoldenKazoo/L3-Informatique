(** This file has been generated by the Catala compiler, do not edit! *)

[@@@ocaml.warning "-4-26-27-32-33-34-37-41-42-69"]

open Catala_runtime


let () =
  match Catala_runtime.check_module "Decimal_internal" "*external*" with
  | Ok () -> ()
  | Error h -> failwith "Hash mismatch for module Decimal_internal, it may need recompiling"
module Decimal_internal = Decimal_internal


(* Toplevel def min *)
let min : decimal -> decimal -> decimal =
  fun (d1: decimal) (d2: decimal) ->  if (o_gt_rat_rat d1 d2) then d2 else d1

(* Toplevel def max *)
let max : decimal -> decimal -> decimal =
  fun (d1: decimal) (d2: decimal) ->  if (o_gt_rat_rat d1 d2) then d1 else d2

(* Toplevel def truncate *)
let truncate : decimal -> decimal =
  fun (d: decimal) ->
     if (o_eq_rat_rat d (decimal_of_string "0")) then (decimal_of_string "0")
      else
      ( if (o_gt_rat_rat d (decimal_of_string "0")) then
         (o_round_rat (o_sub_rat_rat d (decimal_of_string "1/2"))) else
         (o_round_rat (o_add_rat_rat d (decimal_of_string "1/2"))))

(* Toplevel def round_to_decimal *)
let round_to_decimal : decimal -> integer -> decimal =
  fun (d: decimal) (nth_decimal: integer) ->
    (Decimal_internal.round_to_decimal) d nth_decimal

(* Toplevel def sum *)
let sum : (decimal array) -> decimal =
  fun (l: decimal array) ->
    o_fold (fun (total: decimal) (x: decimal) -> o_add_rat_rat total x)
      (decimal_of_string "0") l

(* Toplevel def ceiling *)
let ceiling : decimal -> decimal -> decimal =
  fun (d: decimal) (max_value: decimal) -> min d max_value

(* Toplevel def floor *)
let floor : decimal -> decimal -> decimal =
  fun (d: decimal) (min_value: decimal) -> max d min_value

(* Toplevel def round_by_default *)
let round_by_default : decimal -> decimal =
  fun (d: decimal) ->
     if (o_gt_rat_rat d (decimal_of_string "0")) then (truncate d) else
      ( if (o_eq_rat_rat (truncate d) d) then d else
         (truncate (o_sub_rat_rat d (decimal_of_string "1"))))

(* Toplevel def round_by_excess *)
let round_by_excess : decimal -> decimal =
  fun (d: decimal) ->
     if (o_gte_rat_rat d (decimal_of_string "0")) then
      ( if (o_eq_rat_rat (truncate d) d) then d else
         (truncate (o_add_rat_rat d (decimal_of_string "1")))) else
      (o_round_rat (o_add_rat_rat d (decimal_of_string "1/2")))

(* Toplevel def positive *)
let positive : decimal -> decimal =
  fun (d: decimal) -> floor d (decimal_of_string "0")

let () =
  Catala_runtime.register_module "Decimal_en"
    [ "min", Stdlib.Obj.repr min;
      "max", Stdlib.Obj.repr max;
      "truncate", Stdlib.Obj.repr truncate;
      "round_to_decimal", Stdlib.Obj.repr round_to_decimal;
      "sum", Stdlib.Obj.repr sum;
      "ceiling", Stdlib.Obj.repr ceiling;
      "floor", Stdlib.Obj.repr floor;
      "round_by_default", Stdlib.Obj.repr round_by_default;
      "round_by_excess", Stdlib.Obj.repr round_by_excess;
      "positive", Stdlib.Obj.repr positive ]
    "CM0|15e33851|32e49b03|2ee7fc57"
